using ACS.VerticalHost.Services;
using ACS.VerticalHost.Commands;
using ACS.Service.Data;
using Microsoft.Extensions.Logging;
using ServiceMissingIndex = ACS.Service.Data.MissingIndexRecommendation;
using CommandMissingIndex = ACS.VerticalHost.Commands.MissingIndexRecommendation;

namespace ACS.VerticalHost.Handlers;

public class RebuildIndexCommandHandler : ICommandHandler<RebuildIndexCommand, bool>
{
    private readonly IIndexAnalyzer _indexAnalyzer;
    private readonly ILogger<RebuildIndexCommandHandler> _logger;

    public RebuildIndexCommandHandler(
        IIndexAnalyzer indexAnalyzer,
        ILogger<RebuildIndexCommandHandler> logger)
    {
        _indexAnalyzer = indexAnalyzer;
        _logger = logger;
    }

    public async Task<bool> HandleAsync(RebuildIndexCommand command, CancellationToken cancellationToken)
    {
        try
        {
            if (string.IsNullOrEmpty(command.TableName) || string.IsNullOrEmpty(command.IndexName))
            {
                throw new ArgumentException("TableName and IndexName are required");
            }

            _logger.LogInformation("Processing index rebuild for {IndexName} on {TableName}", 
                command.IndexName, command.TableName);
            
            var success = await _indexAnalyzer.RebuildIndexAsync(command.TableName, command.IndexName);
            
            if (success)
            {
                _logger.LogInformation("Index {IndexName} on table {TableName} rebuilt successfully", 
                    command.IndexName, command.TableName);
            }
            else
            {
                _logger.LogWarning("Failed to rebuild index {IndexName} on table {TableName}", 
                    command.IndexName, command.TableName);
            }

            return success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error rebuilding index {IndexName} on table {TableName}", 
                command.IndexName, command.TableName);
            throw;
        }
    }
}

public class ReorganizeIndexCommandHandler : ICommandHandler<ReorganizeIndexCommand, bool>
{
    private readonly IIndexAnalyzer _indexAnalyzer;
    private readonly ILogger<ReorganizeIndexCommandHandler> _logger;

    public ReorganizeIndexCommandHandler(
        IIndexAnalyzer indexAnalyzer,
        ILogger<ReorganizeIndexCommandHandler> logger)
    {
        _indexAnalyzer = indexAnalyzer;
        _logger = logger;
    }

    public async Task<bool> HandleAsync(ReorganizeIndexCommand command, CancellationToken cancellationToken)
    {
        try
        {
            if (string.IsNullOrEmpty(command.TableName) || string.IsNullOrEmpty(command.IndexName))
            {
                throw new ArgumentException("TableName and IndexName are required");
            }

            _logger.LogInformation("Processing index reorganize for {IndexName} on {TableName}", 
                command.IndexName, command.TableName);
            
            var success = await _indexAnalyzer.ReorganizeIndexAsync(command.TableName, command.IndexName);
            
            if (success)
            {
                _logger.LogInformation("Index {IndexName} on table {TableName} reorganized successfully", 
                    command.IndexName, command.TableName);
            }
            else
            {
                _logger.LogWarning("Failed to reorganize index {IndexName} on table {TableName}", 
                    command.IndexName, command.TableName);
            }

            return success;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error reorganizing index {IndexName} on table {TableName}", 
                command.IndexName, command.TableName);
            throw;
        }
    }
}

public class AnalyzeIndexesQueryHandler : IQueryHandler<AnalyzeIndexesQuery, IndexAnalysisReport>
{
    private readonly IIndexAnalyzer _indexAnalyzer;
    private readonly ILogger<AnalyzeIndexesQueryHandler> _logger;

    public AnalyzeIndexesQueryHandler(
        IIndexAnalyzer indexAnalyzer,
        ILogger<AnalyzeIndexesQueryHandler> logger)
    {
        _indexAnalyzer = indexAnalyzer;
        _logger = logger;
    }

    public async Task<IndexAnalysisReport> HandleAsync(AnalyzeIndexesQuery query, CancellationToken cancellationToken)
    {
        try
        {
            _logger.LogInformation("Processing index analysis request");
            
            var report = await _indexAnalyzer.AnalyzeIndexesAsync();
            
            return new Commands.IndexAnalysisReport
            {
                AnalysisDate = report.AnalysisDate,
                DatabaseName = report.DatabaseName,
                TotalIndexes = report.TotalIndexes,
                HealthScore = report.HealthScore,
                IndexStatistics = report.IndexStatistics.Select(i => new Commands.IndexStatistic
                {
                    TableName = i.TableName,
                    IndexName = i.IndexName,
                    UserSeeks = i.UserSeeks,
                    UserScans = i.UserScans,
                    UserLookups = i.UserLookups,
                    SizeMB = i.SizeMB
                }).ToList(),
                MissingIndexes = report.MissingIndexes.Select(m => new CommandMissingIndex
                {
                    TableName = m.TableName,
                    ImprovementMeasure = m.ImprovementMeasure,
                    AverageImpact = m.AverageImpact,
                    AverageCost = m.AverageCost,
                    TotalSeeksScans = m.TotalSeeksScans,
                    EqualityColumns = m.EqualityColumns,
                    InequalityColumns = m.InequalityColumns,
                    IncludedColumns = m.IncludedColumns,
                    LastUserSeek = m.LastUserSeek,
                    CreateStatement = m.CreateStatement
                }).ToList(),
                UnusedIndexes = report.UnusedIndexes.Select(u => new Commands.UnusedIndexInfo
                {
                    SchemaName = u.SchemaName,
                    TableName = u.TableName,
                    IndexName = u.IndexName,
                    IndexType = u.IndexType,
                    SizeMB = u.SizeMB,
                    DaysSinceLastUse = u.DaysSinceLastUse,
                    UserSeeks = u.UserSeeks,
                    UserScans = u.UserScans,
                    UserLookups = u.UserLookups,
                    UserUpdates = u.UserUpdates
                }).ToList(),
                FragmentedIndexes = report.FragmentedIndexes.Select(f => new Commands.FragmentedIndexInfo
                {
                    SchemaName = f.SchemaName,
                    TableName = f.TableName,
                    IndexName = f.IndexName,
                    FragmentationPercent = f.FragmentationPercent,
                    PageCount = f.PageCount,
                    RecordCount = f.RecordCount,
                    AvgPageSpaceUsed = f.AvgPageSpaceUsed,
                    FillFactor = f.FillFactor,
                    RecommendedAction = f.RecommendedAction
                }).ToList(),
                DuplicateIndexes = report.DuplicateIndexes.Select(d => new Commands.DuplicateIndexInfo
                {
                    TableName = d.TableName,
                    IndexName1 = d.IndexName1,
                    IndexName2 = d.IndexName2,
                    Columns = d.Columns
                }).ToList(),
                Recommendations = report.Recommendations
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error performing index analysis");
            throw;
        }
    }
}

public class GetMissingIndexRecommendationsQueryHandler : IQueryHandler<GetMissingIndexRecommendationsQuery, List<MissingIndexRecommendation>>
{
    private readonly IIndexAnalyzer _indexAnalyzer;
    private readonly ILogger<GetMissingIndexRecommendationsQueryHandler> _logger;

    public GetMissingIndexRecommendationsQueryHandler(
        IIndexAnalyzer indexAnalyzer,
        ILogger<GetMissingIndexRecommendationsQueryHandler> logger)
    {
        _indexAnalyzer = indexAnalyzer;
        _logger = logger;
    }

    public async Task<List<MissingIndexRecommendation>> HandleAsync(GetMissingIndexRecommendationsQuery query, CancellationToken cancellationToken)
    {
        try
        {
            var recommendations = await _indexAnalyzer.GetMissingIndexRecommendationsAsync();
            
            return recommendations.Select(r => new CommandMissingIndex
            {
                TableName = r.TableName,
                ImprovementMeasure = r.ImprovementMeasure,
                AverageImpact = r.AverageImpact,
                AverageCost = r.AverageCost,
                TotalSeeksScans = r.TotalSeeksScans,
                EqualityColumns = r.EqualityColumns,
                InequalityColumns = r.InequalityColumns,
                IncludedColumns = r.IncludedColumns,
                LastUserSeek = r.LastUserSeek,
                CreateStatement = r.CreateStatement
            }).ToList();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting missing index recommendations");
            throw;
        }
    }
}

public class GetUnusedIndexesQueryHandler : IQueryHandler<GetUnusedIndexesQuery, List<UnusedIndexInfo>>
{
    private readonly IIndexAnalyzer _indexAnalyzer;
    private readonly ILogger<GetUnusedIndexesQueryHandler> _logger;

    public GetUnusedIndexesQueryHandler(
        IIndexAnalyzer indexAnalyzer,
        ILogger<GetUnusedIndexesQueryHandler> logger)
    {
        _indexAnalyzer = indexAnalyzer;
        _logger = logger;
    }

    public async Task<List<UnusedIndexInfo>> HandleAsync(GetUnusedIndexesQuery query, CancellationToken cancellationToken)
    {
        try
        {
            var unusedIndexes = await _indexAnalyzer.GetUnusedIndexesAsync(query.DaysSinceLastUse);
            
            return unusedIndexes.Select(i => new Commands.UnusedIndexInfo
            {
                SchemaName = i.SchemaName,
                TableName = i.TableName,
                IndexName = i.IndexName,
                IndexType = i.IndexType,
                SizeMB = i.SizeMB,
                DaysSinceLastUse = i.DaysSinceLastUse,
                UserSeeks = i.UserSeeks,
                UserScans = i.UserScans,
                UserLookups = i.UserLookups,
                UserUpdates = i.UserUpdates
            }).ToList();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting unused indexes");
            throw;
        }
    }
}

public class GetFragmentedIndexesQueryHandler : IQueryHandler<GetFragmentedIndexesQuery, List<FragmentedIndexInfo>>
{
    private readonly IIndexAnalyzer _indexAnalyzer;
    private readonly ILogger<GetFragmentedIndexesQueryHandler> _logger;

    public GetFragmentedIndexesQueryHandler(
        IIndexAnalyzer indexAnalyzer,
        ILogger<GetFragmentedIndexesQueryHandler> logger)
    {
        _indexAnalyzer = indexAnalyzer;
        _logger = logger;
    }

    public async Task<List<FragmentedIndexInfo>> HandleAsync(GetFragmentedIndexesQuery query, CancellationToken cancellationToken)
    {
        try
        {
            var fragmentedIndexes = await _indexAnalyzer.GetFragmentedIndexesAsync(query.FragmentationThreshold);
            
            return fragmentedIndexes.Select(i => new Commands.FragmentedIndexInfo
            {
                SchemaName = i.SchemaName,
                TableName = i.TableName,
                IndexName = i.IndexName,
                FragmentationPercent = i.FragmentationPercent,
                PageCount = i.PageCount,
                RecordCount = i.RecordCount,
                AvgPageSpaceUsed = i.AvgPageSpaceUsed,
                FillFactor = i.FillFactor,
                RecommendedAction = i.RecommendedAction
            }).ToList();
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting fragmented indexes");
            throw;
        }
    }
}